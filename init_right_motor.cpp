// init_right_motor.cpp
//
// C++ version of Python script init_right_motor.py (RIGHT MOTOR - NODE 2 complete init)
//
// Uses Linux SocketCAN (raw CAN) on can0.
// Build:  g++ -std=c++17 -O2 -Wall init_right_motor.cpp -o init_right_motor
// Run:    sudo ./init_right_motor

#include <linux/can.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <unistd.h>

#include <array>
#include <cerrno>
#include <chrono>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

using namespace std::chrono;

static void sleep_ms(int ms) {
  std::this_thread::sleep_for(std::chrono::milliseconds(ms));
}
static void sleep_us(int us) {
  std::this_thread::sleep_for(std::chrono::microseconds(us));
}

class CanSocket {
 public:
  explicit CanSocket(const std::string& ifname) {
    fd_ = ::socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (fd_ < 0) {
      throw std::runtime_error(std::string("socket(PF_CAN) failed: ") + std::strerror(errno));
    }

    struct ifreq ifr;
    std::memset(&ifr, 0, sizeof(ifr));
    std::snprintf(ifr.ifr_name, IFNAMSIZ, "%s", ifname.c_str());
    if (ioctl(fd_, SIOCGIFINDEX, &ifr) < 0) {
      ::close(fd_);
      throw std::runtime_error(std::string("ioctl(SIOCGIFINDEX) failed: ") + std::strerror(errno));
    }

    struct sockaddr_can addr;
    std::memset(&addr, 0, sizeof(addr));
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    if (bind(fd_, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0) {
      ::close(fd_);
      throw std::runtime_error(std::string("bind(AF_CAN) failed: ") + std::strerror(errno));
    }
  }

  ~CanSocket() {
    if (fd_ >= 0) ::close(fd_);
  }

  bool send_frame(uint32_t can_id, const uint8_t* data, uint8_t len) {
    if (len > 8) len = 8;
    struct can_frame fr;
    std::memset(&fr, 0, sizeof(fr));
    fr.can_id = can_id;         // standard 11-bit id
    fr.can_dlc = len;
    if (data && len) std::memcpy(fr.data, data, len);

    const ssize_t n = ::write(fd_, &fr, sizeof(fr));
    if (n != (ssize_t)sizeof(fr)) {
      std::cerr << "CAN write failed (id=0x" << std::hex << can_id << std::dec
                << "): " << std::strerror(errno) << "\n";
      return false;
    }
    return true;
  }

  // Wait for one frame up to timeout_ms. Returns true and fills out if received.
  bool recv_frame(struct can_frame& out, int timeout_ms) {
    fd_set rfds;
    FD_ZERO(&rfds);
    FD_SET(fd_, &rfds);

    struct timeval tv;
    tv.tv_sec = timeout_ms / 1000;
    tv.tv_usec = (timeout_ms % 1000) * 1000;

    int r = select(fd_ + 1, &rfds, nullptr, nullptr, &tv);
    if (r < 0) {
      std::cerr << "select() failed: " << std::strerror(errno) << "\n";
      return false;
    }
    if (r == 0) return false; // timeout

    ssize_t n = ::read(fd_, &out, sizeof(out));
    return (n == (ssize_t)sizeof(out));
  }

 private:
  int fd_{-1};
};

// Little-endian pack for RPDO: <H i H>
static std::array<uint8_t, 8> pack_rpdo(uint16_t ctrl, int32_t vel, uint16_t pad) {
  std::array<uint8_t, 8> b{};
  b[0] = (uint8_t)(ctrl & 0xFF);
  b[1] = (uint8_t)((ctrl >> 8) & 0xFF);

  b[2] = (uint8_t)(vel & 0xFF);
  b[3] = (uint8_t)((vel >> 8) & 0xFF);
  b[4] = (uint8_t)((vel >> 16) & 0xFF);
  b[5] = (uint8_t)((vel >> 24) & 0xFF);

  b[6] = (uint8_t)(pad & 0xFF);
  b[7] = (uint8_t)((pad >> 8) & 0xFF);
  return b;
}

static bool wait_for_sdo_response(CanSocket& can, uint32_t expected_id, double timeout_sec) {
  auto start = steady_clock::now();
  while (duration<double>(steady_clock::now() - start).count() < timeout_sec) {
    struct can_frame fr;
    if (can.recv_frame(fr, 100)) { // 0.1s like Python
      if ((fr.can_id & CAN_EFF_MASK) == expected_id) {
        return true;
      }
    }
  }
  std::cerr << "  WARNING: No SDO response!\n";
  return false;
}

static bool send_sdo(CanSocket& can, const std::array<uint8_t, 8>& data,
                     uint32_t sdo_tx_id, uint32_t sdo_rx_id) {
  if (!can.send_frame(sdo_tx_id, data.data(), 8)) return false;
  return wait_for_sdo_response(can, sdo_rx_id, 0.5);
}

static void send_nmt(CanSocket& can, uint8_t cmd, uint8_t node_id) {
  uint8_t b[2] = {cmd, node_id};
  can.send_frame(0x000, b, 2);
  sleep_ms(100);
}

static void send_cmd_rpdo_and_sync(CanSocket& can, uint32_t rpdo_id, uint16_t ctrl, int32_t vel) {
  auto payload = pack_rpdo(ctrl, vel, 0);
  can.send_frame(rpdo_id, payload.data(), 8);
  sleep_us(2000);              // time.sleep(0.002)
  can.send_frame(0x080, nullptr, 0); // SYNC
  sleep_us(8000);              // time.sleep(0.008)
}

int main() {
  try {
    CanSocket can("can0");

    constexpr uint8_t NODE = 2;

    // IDs for Node 2 (same as Python hard-coded)
    const uint32_t SDO_TX = 0x602;
    const uint32_t SDO_RX = 0x582;
    const uint32_t RPDO   = 0x502;

    std::cout << "======================================================================\n";
    std::cout << "RIGHT MOTOR (NODE 2) - COMPLETE INITIALIZATION\n";
    std::cout << "======================================================================\n";

    // [1/9] Reset node 2
    std::cout << "\n[1/9] Resetting Node 2...\n";
    send_nmt(can, 0x80, NODE);   // reset node (as in Python version)
    sleep_ms(500);

    // [2/9] Manufacturer parameters
    std::cout << "[2/9] Configuring manufacturer parameters...\n";
    send_sdo(can, {0x42, 0x02, 0x20, 0x05, 0x00, 0x00, 0x00, 0x00}, SDO_TX, SDO_RX);

    // [3/9] PDO mappings
    std::cout << "[3/9] PDO mappings...\n";
    send_sdo(can, {0x42,0x00,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x00,0x14,0x01,0x01,0x02,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x01,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x01,0x14,0x01,0x01,0x03,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x02,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x02,0x14,0x01,0x01,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x03,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x03,0x14,0x01,0x01,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x04,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x04,0x14,0x01,0x21,0x04,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x14,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x14,0x14,0x01,0x01,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x15,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x15,0x14,0x01,0x11,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x16,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x16,0x14,0x01,0x21,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x17,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x17,0x14,0x01,0x31,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x19,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x19,0x14,0x01,0x00,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x20,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x20,0x14,0x01,0x51,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x21,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x21,0x14,0x01,0x61,0x05,0x00,0x80}, SDO_TX, SDO_RX);

    // [4/9] Motor parameters
    std::cout << "[4/9] Motor parameters...\n";
    send_sdo(can, {0x42,0xCA,0x20,0x07,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0xCA,0x20,0x08,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0xCA,0x20,0x09,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0xCA,0x20,0x0A,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0xD8,0x20,0x09,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x0F,0x20,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0xD8,0x20,0x0C,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0xD8,0x20,0x24,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    // [5/9] Advanced config
    std::cout << "[5/9] Advanced config...\n";
    send_sdo(can, {0x21,0x3C,0x20,0x09,0x08,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x00,0xFF,0x40,0x55,0x55,0x0D,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x11,0x00,0x40,0x55,0x55,0x0D,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x40,0x3C,0x20,0x09,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x60,0x3C,0x20,0x09,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x70,0x3C,0x20,0x09,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    // [6/9] Profile parameters
    std::cout << "[6/9] Profile parameters...\n";
    send_sdo(can, {0x23,0x37,0x20,0x01,0x00,0x00,0x1E,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x37,0x20,0x02,0x11,0x11,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x37,0x20,0x03,0x11,0x11,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x37,0x20,0x04,0x55,0x55,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x37,0x20,0x05,0xAA,0xAA,0x1A,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x37,0x20,0x06,0x56,0x55,0xE5,0xFF}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x37,0x20,0x07,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x02,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x03,0x00,0x00,0x00,0x40}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x04,0x00,0x00,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x05,0x64,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x06,0x64,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x07,0xA0,0x0F,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x08,0x00,0x00,0x00,0x40}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x09,0x00,0x00,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x0A,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x39,0x20,0x0B,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    // [7/9] RPDO/TPDO mappings...
    std::cout << "[7/9] RPDO/TPDO mappings...\n";
    send_sdo(can, {0x42,0x03,0x14,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x03,0x14,0x01,0x02,0x05,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x03,0x14,0x01,0x02,0x05,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x03,0x14,0x02,0x01,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    send_sdo(can, {0x42,0x03,0x18,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x03,0x18,0x01,0x82,0x01,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x03,0x18,0x01,0x82,0x01,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x03,0x18,0x02,0x01,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    send_sdo(can, {0x42,0x14,0x18,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x14,0x18,0x01,0x82,0x02,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x14,0x18,0x01,0x82,0x02,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x14,0x18,0x02,0x01,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    send_sdo(can, {0x42,0x16,0x18,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x16,0x18,0x01,0x82,0x03,0x00,0x80}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x16,0x18,0x01,0x82,0x03,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x16,0x18,0x02,0x01,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    send_sdo(can, {0x42,0x19,0x18,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x19,0x18,0x01,0x82,0x04,0x00,0x80}, SDO_TX, SDO_RX);

    send_sdo(can, {0x2F,0x19,0x1A,0x00,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x19,0x1A,0x01,0x10,0x01,0x0F,0x20}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x19,0x1A,0x02,0x10,0x02,0x02,0x20}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x19,0x1A,0x03,0x10,0x03,0x02,0x20}, SDO_TX, SDO_RX);
    send_sdo(can, {0x23,0x19,0x1A,0x04,0x10,0x05,0x02,0x20}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x19,0x1A,0x00,0x04,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    send_sdo(can, {0x23,0x19,0x18,0x01,0x82,0x04,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x19,0x18,0x02,0x01,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    // [8/9] Reset & control word sequence
    std::cout << "[8/9] Reset & control word sequence...\n";
    send_nmt(can, 0x80, NODE);
    sleep_ms(200);

    send_sdo(can, {0x2B,0x40,0x60,0x00,0x80,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);
    send_sdo(can, {0x2F,0x60,0x60,0x00,0x03,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);
    send_sdo(can, {0x23,0xFF,0x60,0x00,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);
    send_sdo(can, {0x2B,0x40,0x60,0x00,0x80,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);
    send_sdo(can, {0x2B,0x40,0x60,0x00,0x06,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);
    send_sdo(can, {0x2B,0x40,0x60,0x00,0x07,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);
    send_sdo(can, {0x2B,0x40,0x60,0x00,0x0F,0x00,0x00,0x00}, SDO_TX, SDO_RX); sleep_ms(100);

    // [9/9] Start node
    std::cout << "[9/9] Starting node...\n";
    send_nmt(can, 0x01, NODE);
    sleep_ms(500);

    // [10/11] Final configuration
    std::cout << "[10/11] Final configuration...\n";
    send_sdo(can, {0x2B,0x86,0x60,0x00,0x02,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x21,0x3C,0x20,0x01,0x06,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x01,0x3E,0xC3,0xAE,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x21,0x3C,0x20,0x02,0x06,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x01,0x3E,0xC3,0xAE,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x21,0x3C,0x20,0x03,0x06,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x01,0x3E,0xC3,0xAE,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x21,0x3C,0x20,0x04,0x06,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x01,0x3E,0xC3,0xAE,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);

    send_sdo(can, {0x2B,0x0C,0x10,0x00,0x0A,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2F,0x0D,0x10,0x00,0xFA,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2B,0x5A,0x20,0x40,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2B,0x5A,0x20,0x2E,0x01,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2B,0x5A,0x20,0x01,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x2B,0x65,0x20,0x2B,0x0A,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    send_sdo(can, {0x42,0x41,0x60,0x00,0x00,0x00,0x00,0x00}, SDO_TX, SDO_RX);
    sleep_ms(200);

    // [11/11] State machine via RPDO (motor engage)
    std::cout << "[11/11] State machine via RPDO (MOTOR ENGAGE)...\n";
    send_cmd_rpdo_and_sync(can, RPDO, 0x0080, 0); // Fault reset
    for (int i = 0; i < 5; i++) send_cmd_rpdo_and_sync(can, RPDO, 0x0006, 0);  // Shutdown
    for (int i = 0; i < 5; i++) send_cmd_rpdo_and_sync(can, RPDO, 0x0007, 0);  // Switch on
    for (int i = 0; i < 10; i++) send_cmd_rpdo_and_sync(can, RPDO, 0x000F, 0); // Enable operation

    std::cout << "\nâœ“ RIGHT MOTOR INITIALIZED AND ENGAGED!\n";
    std::cout << "  Run the RPDO speed test script now\n";
    return 0;

  } catch (const std::exception& e) {
    std::cerr << "Fatal: " << e.what() << "\n";
    return 1;
  }
}
