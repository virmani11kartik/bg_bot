// init_left_motor.cpp
//
// Build:
//   g++ -std=c++17 -O2 -Wall -Wextra init_left_motor.cpp -o init_left_motor
//
// Run (needs CAN interface up, and usually root or CAP_NET_RAW):
//   sudo ./init_left_motor

#include <linux/can.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <unistd.h>

#include <array>
#include <cerrno>
#include <csignal>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

static volatile std::sig_atomic_t g_stop = 0;

static void on_sigint(int) { g_stop = 1; }

static void sleep_ms(int ms) {
  std::this_thread::sleep_for(std::chrono::milliseconds(ms));
}

static void sleep_us(int us) {
  std::this_thread::sleep_for(std::chrono::microseconds(us));
}

class CanSocket {
public:
  CanSocket(const std::string& ifname) : fd_(-1) {
    fd_ = ::socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (fd_ < 0) {
      throw std::runtime_error("socket(PF_CAN) failed: " + std::string(std::strerror(errno)));
    }

    struct ifreq ifr {};
    std::snprintf(ifr.ifr_name, IFNAMSIZ, "%s", ifname.c_str());
    if (::ioctl(fd_, SIOCGIFINDEX, &ifr) < 0) {
      ::close(fd_);
      throw std::runtime_error("ioctl(SIOCGIFINDEX) failed: " + std::string(std::strerror(errno)));
    }

    struct sockaddr_can addr {};
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    if (::bind(fd_, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0) {
      ::close(fd_);
      throw std::runtime_error("bind(AF_CAN) failed: " + std::string(std::strerror(errno)));
    }
  }

  ~CanSocket() {
    if (fd_ >= 0) ::close(fd_);
  }

  bool send_frame(uint32_t can_id, const uint8_t* data, uint8_t len) {
    if (len > 8) return false;
    struct can_frame fr {};
    fr.can_id = can_id;      // standard 11-bit by default
    fr.can_dlc = len;
    if (data && len) std::memcpy(fr.data, data, len);

    const ssize_t n = ::write(fd_, &fr, sizeof(fr));
    if (n != static_cast<ssize_t>(sizeof(fr))) {
      std::cerr << "ERROR: write() failed: " << std::strerror(errno) << "\n";
      return false;
    }
    return true;
  }

  // Read one frame with timeout (ms). Returns true if a frame was read.
  bool recv_frame(struct can_frame& out, int timeout_ms) {
    fd_set rfds;
    FD_ZERO(&rfds);
    FD_SET(fd_, &rfds);

    struct timeval tv {};
    tv.tv_sec  = timeout_ms / 1000;
    tv.tv_usec = (timeout_ms % 1000) * 1000;

    const int r = ::select(fd_ + 1, &rfds, nullptr, nullptr, &tv);
    if (r < 0) {
      if (errno == EINTR) return false;
      std::cerr << "ERROR: select() failed: " << std::strerror(errno) << "\n";
      return false;
    }
    if (r == 0) return false; // timeout

    const ssize_t n = ::read(fd_, &out, sizeof(out));
    if (n < 0) {
      if (errno == EINTR) return false;
      std::cerr << "ERROR: read() failed: " << std::strerror(errno) << "\n";
      return false;
    }
    if (n != static_cast<ssize_t>(sizeof(out))) return false;
    return true;
  }

private:
  int fd_;
};

// Pack little-endian helper
static inline void le16(uint8_t* p, uint16_t v) {
  p[0] = static_cast<uint8_t>(v & 0xFF);
  p[1] = static_cast<uint8_t>((v >> 8) & 0xFF);
}
static inline void le32(uint8_t* p, int32_t v) {
  uint32_t u = static_cast<uint32_t>(v);
  p[0] = static_cast<uint8_t>(u & 0xFF);
  p[1] = static_cast<uint8_t>((u >> 8) & 0xFF);
  p[2] = static_cast<uint8_t>((u >> 16) & 0xFF);
  p[3] = static_cast<uint8_t>((u >> 24) & 0xFF);
}

struct CobIds {
  uint32_t sdo_req;
  uint32_t sdo_resp;
  uint32_t rpdo1;
  uint32_t sync;
  uint32_t nmt;
};

static CobIds make_cob_ids(uint8_t node_id) {
  CobIds c{};
  c.sdo_req  = 0x600 + node_id;
  c.sdo_resp = 0x580 + node_id;
  c.rpdo1    = 0x500 + node_id; // same with python 0x501 for node 1
  c.sync     = 0x080;
  c.nmt      = 0x000;
  return c;
}

static bool wait_for_sdo_response(CanSocket& can, uint32_t sdo_resp_id, double timeout_sec) {
  const auto start = std::chrono::steady_clock::now();
  while (true) {
    const auto now = std::chrono::steady_clock::now();
    const double elapsed = std::chrono::duration<double>(now - start).count();
    if (elapsed >= timeout_sec) break;

    struct can_frame fr {};
    if (!can.recv_frame(fr, 100)) continue;
    if (fr.can_id == sdo_resp_id) {
      return true;
    }
  }
  std::cerr << "  WARNING: No SDO response!\n";
  return false;
}

static bool send_sdo(CanSocket& can, const CobIds& cob, const std::array<uint8_t, 8>& data) {
  if (!can.send_frame(cob.sdo_req, data.data(), 8)) return false;
  return wait_for_sdo_response(can, cob.sdo_resp, 0.5);
}

static void send_nmt(CanSocket& can, const CobIds& cob, uint8_t cmd, uint8_t node) {
  uint8_t data[2] = {cmd, node};
  can.send_frame(cob.nmt, data, 2);
  sleep_ms(100);
}

// RPDO payload: struct.pack('<HiH', ctrl, vel, 0)
static void send_cmd(CanSocket& can, const CobIds& cob, uint16_t ctrl, int32_t vel) {
  uint8_t data[8] = {0};
  le16(&data[0], ctrl);
  le32(&data[2], vel);
  le16(&data[6], 0);

  can.send_frame(cob.rpdo1, data, 8);
  sleep_us(2000); // 0.002s
  can.send_frame(cob.sync, nullptr, 0);
  sleep_us(8000); // 0.008s
}

int main() {
  std::signal(SIGINT, on_sigint);

  const std::string IFACE = "can0";
  const uint8_t NODE_ID = 1; // same with python (0x601/0x581 and 0x501)

  const CobIds cob = make_cob_ids(NODE_ID);

  try {
    CanSocket can(IFACE);

    std::cout << "======================================================================\n";
    std::cout << "COMPLETE INITIALIZATION - With SDO response verification (C++)\n";
    std::cout << "======================================================================\n";

    // Reset nodes 1,2,3,4...
    std::cout << "\n[1/9] Resetting nodes 1,2,3,4...\n";
    for (uint8_t n : {uint8_t(1), uint8_t(2), uint8_t(3), uint8_t(4)}) {
      send_nmt(can, cob, 0x80, n); // Reset Node
    }
    sleep_ms(500);

    // SDO configurations
    std::cout << "[2/9] Configuring manufacturer parameters...\n";
    std::cout << "  (Waiting for each SDO response...)\n";

    int sdo_count = 0;

    auto S = [&](std::array<uint8_t,8> d) {
      (void)send_sdo(can, cob, d);
    };

    // First SDO
    S({0x42, 0x02, 0x20, 0x05, 0x00, 0x00, 0x00, 0x00});
    sdo_count += 1;

    // PDO configuration
    std::cout << "  [" << sdo_count << "] PDO mappings...\n";
    S({0x42, 0x00, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x00, 0x14, 0x01, 0x01, 0x02, 0x00, 0x80});
    S({0x42, 0x01, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x01, 0x14, 0x01, 0x01, 0x03, 0x00, 0x80});
    S({0x42, 0x02, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x02, 0x14, 0x01, 0x01, 0x05, 0x00, 0x80});
    S({0x42, 0x03, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x03, 0x14, 0x01, 0x01, 0x05, 0x00, 0x80});
    S({0x42, 0x04, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x04, 0x14, 0x01, 0x21, 0x04, 0x00, 0x80});
    sdo_count += 10;

    std::cout << "  [" << sdo_count << "] More PDO mappings...\n";
    S({0x42, 0x14, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x14, 0x14, 0x01, 0x01, 0x05, 0x00, 0x80});
    S({0x42, 0x15, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x15, 0x14, 0x01, 0x11, 0x05, 0x00, 0x80});
    S({0x42, 0x16, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x16, 0x14, 0x01, 0x21, 0x05, 0x00, 0x80});
    S({0x42, 0x17, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x17, 0x14, 0x01, 0x31, 0x05, 0x00, 0x80});
    S({0x42, 0x19, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x19, 0x14, 0x01, 0x00, 0x05, 0x00, 0x80});
    S({0x42, 0x20, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x20, 0x14, 0x01, 0x51, 0x05, 0x00, 0x80});
    S({0x42, 0x21, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x21, 0x14, 0x01, 0x61, 0x05, 0x00, 0x80});
    sdo_count += 14;

    std::cout << "  [" << sdo_count << "] Motor parameters...\n";
    S({0x42, 0xCA, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0xCA, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0xCA, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0xCA, 0x20, 0x0A, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0xD8, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0x0F, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0xD8, 0x20, 0x0C, 0x00, 0x00, 0x00, 0x00});
    S({0x42, 0xD8, 0x20, 0x24, 0x00, 0x00, 0x00, 0x00});
    sdo_count += 8;

    std::cout << "  [" << sdo_count << "] Advanced config...\n";
    S({0x21, 0x3C, 0x20, 0x09, 0x08, 0x00, 0x00, 0x00});
    S({0x00, 0xFF, 0x40, 0x55, 0x55, 0x0D, 0x00, 0x00});
    S({0x11, 0x00, 0x40, 0x55, 0x55, 0x0D, 0x00, 0x00});
    S({0x40, 0x3C, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00});
    S({0x60, 0x3C, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00});
    S({0x70, 0x3C, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00});
    sdo_count += 6;

    std::cout << "  [" << sdo_count << "] Profile parameters (CRITICAL)...\n";
    S({0x23, 0x37, 0x20, 0x01, 0x00, 0x00, 0x1E, 0x00});
    S({0x23, 0x37, 0x20, 0x02, 0x11, 0x11, 0x00, 0x00});
    S({0x23, 0x37, 0x20, 0x03, 0x11, 0x11, 0x00, 0x00});
    S({0x23, 0x37, 0x20, 0x04, 0x55, 0x55, 0x00, 0x00});
    S({0x23, 0x37, 0x20, 0x05, 0xAA, 0xAA, 0x1A, 0x00});
    S({0x23, 0x37, 0x20, 0x06, 0x56, 0x55, 0xE5, 0xFF});
    S({0x23, 0x37, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x03, 0x00, 0x00, 0x00, 0x40});
    S({0x23, 0x39, 0x20, 0x04, 0x00, 0x00, 0x00, 0x80});
    S({0x23, 0x39, 0x20, 0x05, 0x64, 0x00, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x06, 0x64, 0x00, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x07, 0xA0, 0x0F, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x08, 0x00, 0x00, 0x00, 0x40});
    S({0x23, 0x39, 0x20, 0x09, 0x00, 0x00, 0x00, 0x80});
    S({0x23, 0x39, 0x20, 0x0A, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x39, 0x20, 0x0B, 0x00, 0x00, 0x00, 0x00});
    sdo_count += 18;

    std::cout << "[3/9] Configuring RPDO/TPDO mappings...\n";
    S({0x42, 0x03, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x03, 0x14, 0x01, 0x01, 0x05, 0x00, 0x80});
    S({0x23, 0x03, 0x14, 0x01, 0x01, 0x05, 0x00, 0x00});
    S({0x2F, 0x03, 0x14, 0x02, 0x01, 0x00, 0x00, 0x00});

    S({0x42, 0x03, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x03, 0x18, 0x01, 0x81, 0x01, 0x00, 0x80});
    S({0x23, 0x03, 0x18, 0x01, 0x81, 0x01, 0x00, 0x00});
    S({0x2F, 0x03, 0x18, 0x02, 0x01, 0x00, 0x00, 0x00});

    S({0x42, 0x14, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x14, 0x18, 0x01, 0x81, 0x02, 0x00, 0x80});
    S({0x23, 0x14, 0x18, 0x01, 0x81, 0x02, 0x00, 0x00});
    S({0x2F, 0x14, 0x18, 0x02, 0x01, 0x00, 0x00, 0x00});

    S({0x42, 0x16, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x16, 0x18, 0x01, 0x81, 0x03, 0x00, 0x80});
    S({0x23, 0x16, 0x18, 0x01, 0x81, 0x03, 0x00, 0x00});
    S({0x2F, 0x16, 0x18, 0x02, 0x01, 0x00, 0x00, 0x00});

    S({0x42, 0x19, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x19, 0x18, 0x01, 0x81, 0x04, 0x00, 0x80});

    S({0x2F, 0x19, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00});
    S({0x23, 0x19, 0x1A, 0x01, 0x10, 0x01, 0x0F, 0x20});
    S({0x23, 0x19, 0x1A, 0x02, 0x10, 0x02, 0x02, 0x20});
    S({0x23, 0x19, 0x1A, 0x03, 0x10, 0x03, 0x02, 0x20});
    S({0x23, 0x19, 0x1A, 0x04, 0x10, 0x05, 0x02, 0x20});
    S({0x2F, 0x19, 0x1A, 0x00, 0x04, 0x00, 0x00, 0x00});

    S({0x23, 0x19, 0x18, 0x01, 0x81, 0x04, 0x00, 0x00});
    S({0x2F, 0x19, 0x18, 0x02, 0x01, 0x00, 0x00, 0x00});

    std::cout << "[4/9] Reset & control word sequence...\n";
    send_nmt(can, cob, 0x80, 0x01);
    sleep_ms(200);

    S({0x2B, 0x40, 0x60, 0x00, 0x80, 0x00, 0x00, 0x00});
    sleep_ms(100);
    S({0x2F, 0x60, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00});
    sleep_ms(100);
    S({0x23, 0xFF, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00});
    sleep_ms(100);
    S({0x23, 0x83, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00});
    sleep_ms(100);

    S({0x2B, 0x40, 0x60, 0x00, 0x80, 0x00, 0x00, 0x00});
    sleep_ms(100);
    S({0x2B, 0x40, 0x60, 0x00, 0x06, 0x00, 0x00, 0x00});
    sleep_ms(100);
    S({0x2B, 0x40, 0x60, 0x00, 0x07, 0x00, 0x00, 0x00});
    sleep_ms(100);
    S({0x2B, 0x40, 0x60, 0x00, 0x0F, 0x00, 0x00, 0x00});
    sleep_ms(100);

    std::cout << "[5/9] Starting node...\n";
    send_nmt(can, cob, 0x01, 0x01);
    sleep_ms(500);

    std::cout << "[6/9] Final configuration...\n";
    S({0x2B, 0x86, 0x60, 0x00, 0x02, 0x00, 0x00, 0x00});
    S({0x21, 0x3C, 0x20, 0x01, 0x06, 0x00, 0x00, 0x00});
    S({0x01, 0x3E, 0xC3, 0xAE, 0x00, 0x00, 0x00, 0x00});
    S({0x21, 0x3C, 0x20, 0x02, 0x06, 0x00, 0x00, 0x00});
    S({0x01, 0x3E, 0xC3, 0xAE, 0x00, 0x00, 0x00, 0x00});
    S({0x21, 0x3C, 0x20, 0x03, 0x06, 0x00, 0x00, 0x00});
    S({0x01, 0x3E, 0xC3, 0xAE, 0x00, 0x00, 0x00, 0x00});
    S({0x21, 0x3C, 0x20, 0x04, 0x06, 0x00, 0x00, 0x00});
    S({0x01, 0x3E, 0xC3, 0xAE, 0x00, 0x00, 0x00, 0x00});
    S({0x2B, 0x0C, 0x10, 0x00, 0x0A, 0x00, 0x00, 0x00});
    S({0x2F, 0x0D, 0x10, 0x00, 0xFA, 0x00, 0x00, 0x00});

    S({0x2B, 0x5A, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00});
    S({0x2B, 0x5A, 0x20, 0x2E, 0x01, 0x00, 0x00, 0x00});
    S({0x2B, 0x5A, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00});
    S({0x2B, 0x65, 0x20, 0x2B, 0x0A, 0x00, 0x00, 0x00});

    S({0x42, 0x41, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00});
    sleep_ms(200);

    std::cout << "[7/9] State machine via RPDO...\n";
    send_cmd(can, cob, 0x0080, 0);
    for (int i = 0; i < 5; i++) send_cmd(can, cob, 0x0006, 0);
    for (int i = 0; i < 5; i++) send_cmd(can, cob, 0x0007, 0);
    for (int i = 0; i < 10; i++) send_cmd(can, cob, 0x000F, 0);

    std::cout << "\n[8/9] Configuration complete! Check motor status...\n";
    std::cout << "      Run the monitor script to see if status changed to 0x0237\n";
    sleep_ms(1000);

    std::cout << "[9/9] Attempting to run motors...\n";
    std::cout << "      Press Ctrl+C to stop\n\n";

    //  Commented out loop in python - incldued since in python for same purpose
    std::cout << "Run Motors now\n";


    /*
    int i = 0;
    int32_t velocity = 235929;
    while (!g_stop) {
      send_cmd(can, cob, 0x000F, velocity);
      if (i % 100 == 0) {
        std::cout << "[" << (i * 10) << "ms] Sending velocity " << velocity << "...\n";
      }
      i++;
    }
    */

    // Wait until Ctrl+C so cleanup behaves like Python try/except/finally.
    while (!g_stop) {
      sleep_ms(50);
    }

    std::cout << "\n\nStopping...\n";
    for (int k = 0; k < 30; k++) {
      send_cmd(can, cob, 0x000F, 0);
    }
    for (int k = 0; k < 10; k++) {
      send_cmd(can, cob, 0x0006, 0);
    }

    std::cout << "Done! Run monitor script\n";
    return 0;

  } catch (const std::exception& e) {
    std::cerr << "FATAL: " << e.what() << "\n";
    return 1;
  }
}
